<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise对象入门]]></title>
    <url>%2F2019%2F02%2F22%2Fpromiss%2F</url>
    <content type="text"><![CDATA[简介 基本用法 catch finally all #简介 promise对象可以获取异步操作的消息，提供统一的API,各个异步操作都可以用同样的方法进行处理。promise对象不受外界影响，其有三种状态：pending（进行中）、fulfilled（成功）、rejected（失败），只有异步操作的结果可以决定当前状态，一旦状态改变就不可以再变化，状态改变方向有两种：pending -&gt; fulfilled、pending -&gt; rejectedpromise对象的意义就在于将异步操作以同步操作的流程表达，避免层层嵌套的回调函数 #基本用法1234567let promise = new Promise(function (resolve, reject) &#123; if () &#123; resolve(value) // 异步操作成功 &#125; else &#123; reject(error) // 失败抛错 &#125;&#125;) Promise构造函数接受一个函数作为参数，该函数有两个参数：resolve、reject，当执行resolve函数时Promise对象状态pending -&gt; fulfilled，当执行reject时Promise对象状态pending -&gt; rejected 12345promise.then(function (value) &#123; &#125;, function (error) &#123; &#125;) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数，第二个参数为可选参数，例子： 12345678let promise = new Promise(function (resolve, reject) &#123; console.log('promise') resolve('11')&#125;)promise.then(function (value) &#123; console.log(value)&#125;)console.log('22') 执行结果’promise -&gt; 22 -&gt; 11’,promise对象新建后立即执行，then方法的回调会在所有同步任务执行完成后执行 #catchpromise.prototype.catch()是then()方法的别名，用于指定发生错误时的回调函数 1234567new Promise(function () &#123;&#125;).then(() =&gt; &#123;&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 如果异步操作抛出错误，状态就会变为reject，就会调用catch中的回调，当状态为resolve，执行then方法中的回调时，若报错同样回进入catch的回调意义：当我们使用promise异步操作时，但是没有使用catch捕获错误时，若promise异步执行报错时，外部代码并不会接收到错误，而是继续执行不受影响 123456789const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; resolve(x); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log('ok');&#125;);setTimeout(() =&gt; &#123; console.log('continue') &#125;, 100); 如代码所示，x变量并没有定义，期待的操作是执行报错，然后停止运行，实际上continue会执行输出，这说明当没有catch捕获错误时，外部代码不会知道Promise对象内部执行已经报错，因此会继续执行。 #finally不管Promise对象最后结果如何，都会执行的操作，finally方法中的回调函数不接受任何参数1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); #allPromise.all方法用于将多个Promise实例包装成一个新的实例12345Promise.all([p1,p2,p3]).then((array) =&gt; &#123; &#125;).catch((err) =&gt; &#123; &#125;) 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>promiss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道JS闭包面试题]]></title>
    <url>%2F2019%2F02%2F22%2Fbibao%2F</url>
    <content type="text"><![CDATA[说明 解释 总结 #说明最近看到这样一段代码 12345678910111213function fun(n,o)&#123; console.log(o); return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;;&#125;var a = fun(0);a.fun(1);a.fun(2);a.fun(3);var b = fun(0).fun(1).fun(2).fun(3);var c = fun(0).fun(1);c.fun(2);c.fun(3);//问:三行a,b,c的输出分别是什么？ 觉得有点意思，和大家一起来聊聊。我相信如果你不是非常理解JavaScript中的闭包，一定是不想看这段代码的。 #解释好的，我们暂时先不去想这段代码，先看点简单的 123456789function fun0()&#123; var a=1; console.log(a);&#125;function fun1()&#123; console.log(a);&#125;fun0(); //1fun1(); //报错 a is not defined 这段代码，我相信大家应该知道最后为什么结果会是 1 和 报错 的，在函数内声明的变量只在函数体内定义，它们是局部变量，作用域是局部的，所以 函数 fun1 调用后，找不到a，就报错了，JavaScript采用词法作用域，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，所以我们只要改改上面函数 fun1的位置，它就不会报错了。 1234567891011function fun0()&#123; var a=1; console.log(a); //把fun1放在fun0中，就不报错了 function fun1()&#123; console.log(a); &#125; fun1(); //1&#125;fun0(); //1 代码改成这样，只是把fun1 放在 fun0 中就不报错了，函数调用后都输出1好了，我们来看最开始提到的代码，先简化一下 1234function fun(n,o)&#123; return &#123; &#125;&#125; 我们先看这段代码，fun 调用后会怎么样？很明显会返回一个空对象，记住，fun调用后会返回对象，这点很重要。 12345678910function fun(n,o)&#123; console.log(o); return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;; &#125; var a = fun(0); 这里提一句，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。console.log(o); 输出undefinedvar a = fun(0); 那a是值是什么，是fun(0)，返回的那个对象 12345&#123; fun:function(m)&#123; return fun(m,0); &#125;&#125; 这个对象，有一个fun的方法，方法返回的结果就是最外面 fun 调用的结果。 var a=fun(0)，传入一个参数0，那就是说，函数fun中参数 n 的值是0了，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0，这段话是本文的重点， 明白这段，那问题就容易解决了。说到这里，这道题基本上可以解决了，希望大家能听明白我上面说的话，下面的就简单了。我们一步一步看。现在我们知道 a 是 12345&#123; fun:function(m)&#123; return fun(m,0); &#125;&#125; 这样的一个对象a.fun(1); 会怎么样？看代码 12345&#123; fun:function(1)&#123; return fun(1,0); &#125;&#125; a.fun(1); 返回的结果，就是 fun(1,0)，返回的结果 123456789 function fun(n,o)&#123; //n的值为1，o的值为0 console.log(o); return &#123; fun:function(m)&#123; return fun(m,n);//n的值为1 &#125; &#125;;&#125;fun(1,0); //输出0，并返回一个对象，这个对象有一个fun的方法,这个方法调用后，会返回外层fun函数调用的结果，并且外层函数的第二个参数是 n 的值，也就是1 a.fun(2); 会怎么样？看代码 12345&#123; fun:function(2)&#123; return fun(2,0); &#125;&#125; a.fun(2); 返回的结果，就是 fun(2,0)，返回的结果 123456789function fun(n,o)&#123; //n的值为2，o的值为0 console.log(o); return &#123; fun:function(m)&#123; return fun(m,n); //n的值为2 &#125; &#125;;&#125;fun(2,0); //输出0，并返回一个对象，这个对象有一个fun的方法,这个方法调用后，会返回外层fun函数调用的结果，并且外层函数的第二个参数是 n 的值，也就是2 a.fun(3); 就不说了，一样的。 12var a = fun(0); a.fun(1); a.fun(2); a.fun(3);var b = fun(0).fun(1).fun(2).fun(3); 把返回的对象，重新赋值给a，这样两行的结果就是一样的了。var c = fun(0).fun(1); c.fun(2); c.fun(3);c 与他们的不同，只是var c = fun(0).fun(1); 之后用的是同一个对象罢了。 #总结说下结果 12345678var a = fun(0); a.fun(1); a.fun(2); a.fun(3);//undefined 0 0 0 var b = fun(0).fun(1).fun(2).fun(3);//undefined 0 1 2 var c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined 0 1 1 转载来自http://www.cnblogs.com/xxcanghai/p/4991870.html顺便推荐几篇讲解闭包的文章学习Javascript闭包（Closure）Javascript闭包——懂不懂由你，反正我是懂了 JS闭包可被利用的常见场景]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Quick Start Create a new post Run server Generate static files Deploy to remote sites Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. #Quick Start#Create a new post1$ hexo new "My New Post" More info: Writing #Run server1$ hexo server More info: Server #Generate static files1$ hexo generate More info: Generating #Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[welcome]]></title>
    <url>%2F2019%2F01%2F17%2Ftest%2F</url>
    <content type="text"><![CDATA[123456 _ _ _____ _ ___ _____ _ _ _____( ) /\ ( ) ( ____) ( ) / _ \ ( _ ) ( ) ( ) ( ____) \ \ / \ / / | |___ | | | ( (_) | | | | | \ / | | |___ \ \/ \/ / | ___) | | | | _ | | | | | |\ \ / /| | | ___) \ /\ / | |___ | |____ | (_( ) | |_| | | | \ \/ / | | | |___ \_/ \_/ (_____) (______) \___/ (_____) (_) \__/ (_) (_____)]]></content>
      <tags>
        <tag>welcome</tag>
      </tags>
  </entry>
</search>
