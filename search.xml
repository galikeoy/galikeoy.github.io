<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[npm采踩坑系列]]></title>
    <url>%2F2019%2F03%2F06%2Fnpm_eroor%2F</url>
    <content type="text"><![CDATA[#前言这几天想给添加一点东西，于是就用npm安装了一个插件，然后就提示出错了 来踩坑了 错误 解决 #错误证书错误12345npm install -g create-react-app//出错提示UNABLE_TO_VERIFY_LEAF_SIGNATUREUNABLE_TO_VERIFY_LEAF_SIGNATUREunable to verify the first certificate//无法验证第一证书 #解决123//因为npm install走的是https协议，需要通过数字证书来保证的，//所以，取消ssl验证npm config set strict-ssl false]]></content>
      <tags>
        <tag>npm</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise对象入门]]></title>
    <url>%2F2019%2F02%2F22%2Fpromise%2F</url>
    <content type="text"><![CDATA[#简介 promise对象可以获取异步操作的消息，提供统一的API,各个异步操作都可以用同样的方法进行处理。promise对象不受外界影响，其有三种状态：pending（进行中）、fulfilled（成功）、rejected（失败），只有异步操作的结果可以决定当前状态，一旦状态改变就不可以再变化，状态改变方向有两种：pending -&gt; fulfilled、pending -&gt; rejectedpromise对象的意义就在于将异步操作以同步操作的流程表达，避免层层嵌套的回调函数 基本用法 catch finally all #基本用法1234567let promise = new Promise(function (resolve, reject) &#123; if () &#123; resolve(value) // 异步操作成功 &#125; else &#123; reject(error) // 失败抛错 &#125;&#125;) Promise构造函数接受一个函数作为参数，该函数有两个参数：resolve、reject，当执行resolve函数时Promise对象状态pending -&gt; fulfilled，当执行reject时Promise对象状态pending -&gt; rejected 12345promise.then(function (value) &#123; &#125;, function (error) &#123; &#125;) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数，第二个参数为可选参数，例子： 12345678let promise = new Promise(function (resolve, reject) &#123; console.log('promise') resolve('11')&#125;)promise.then(function (value) &#123; console.log(value)&#125;)console.log('22') 执行结果’promise -&gt; 22 -&gt; 11’,promise对象新建后立即执行，then方法的回调会在所有同步任务执行完成后执行 #catchpromise.prototype.catch()是then()方法的别名，用于指定发生错误时的回调函数 1234567new Promise(function () &#123;&#125;).then(() =&gt; &#123;&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 如果异步操作抛出错误，状态就会变为reject，就会调用catch中的回调，当状态为resolve，执行then方法中的回调时，若报错同样回进入catch的回调意义：当我们使用promise异步操作时，但是没有使用catch捕获错误时，若promise异步执行报错时，外部代码并不会接收到错误，而是继续执行不受影响 123456789const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; resolve(x); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log('ok');&#125;);setTimeout(() =&gt; &#123; console.log('continue') &#125;, 100); 如代码所示，x变量并没有定义，期待的操作是执行报错，然后停止运行，实际上continue会执行输出，这说明当没有catch捕获错误时，外部代码不会知道Promise对象内部执行已经报错，因此会继续执行。 #finally不管Promise对象最后结果如何，都会执行的操作，finally方法中的回调函数不接受任何参数1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); #allPromise.all方法用于将多个Promise实例包装成一个新的实例12345Promise.all([p1,p2,p3]).then((array) =&gt; &#123; &#125;).catch((err) =&gt; &#123; &#125;) 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道JS闭包面试题]]></title>
    <url>%2F2019%2F02%2F22%2Fbibao%2F</url>
    <content type="text"><![CDATA[#说明最近看到这样一段代码 12345678910111213function fun(n,o)&#123; console.log(o); return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;;&#125;var a = fun(0);a.fun(1);a.fun(2);a.fun(3);var b = fun(0).fun(1).fun(2).fun(3);var c = fun(0).fun(1);c.fun(2);c.fun(3);//问:三行a,b,c的输出分别是什么？ 觉得有点意思，和大家一起来聊聊。我相信如果你不是非常理解JavaScript中的闭包，一定是不想看这段代码的。 解释 总结 #解释好的，我们暂时先不去想这段代码，先看点简单的 123456789function fun0()&#123; var a=1; console.log(a);&#125;function fun1()&#123; console.log(a);&#125;fun0(); //1fun1(); //报错 a is not defined 这段代码，我相信大家应该知道最后为什么结果会是 1 和 报错 的，在函数内声明的变量只在函数体内定义，它们是局部变量，作用域是局部的，所以 函数 fun1 调用后，找不到a，就报错了，JavaScript采用词法作用域，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，所以我们只要改改上面函数 fun1的位置，它就不会报错了。 1234567891011function fun0()&#123; var a=1; console.log(a); //把fun1放在fun0中，就不报错了 function fun1()&#123; console.log(a); &#125; fun1(); //1&#125;fun0(); //1 代码改成这样，只是把fun1 放在 fun0 中就不报错了，函数调用后都输出1好了，我们来看最开始提到的代码，先简化一下 1234function fun(n,o)&#123; return &#123; &#125;&#125; 我们先看这段代码，fun 调用后会怎么样？很明显会返回一个空对象，记住，fun调用后会返回对象，这点很重要。 12345678910function fun(n,o)&#123; console.log(o); return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;; &#125; var a = fun(0); 这里提一句，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。console.log(o); 输出undefinedvar a = fun(0); 那a是值是什么，是fun(0)，返回的那个对象 12345&#123; fun:function(m)&#123; return fun(m,0); &#125;&#125; 这个对象，有一个fun的方法，方法返回的结果就是最外面 fun 调用的结果。 var a=fun(0)，传入一个参数0，那就是说，函数fun中参数 n 的值是0了，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0，这段话是本文的重点， 明白这段，那问题就容易解决了。说到这里，这道题基本上可以解决了，希望大家能听明白我上面说的话，下面的就简单了。我们一步一步看。现在我们知道 a 是 12345&#123; fun:function(m)&#123; return fun(m,0); &#125;&#125; 这样的一个对象a.fun(1); 会怎么样？看代码 12345&#123; fun:function(1)&#123; return fun(1,0); &#125;&#125; a.fun(1); 返回的结果，就是 fun(1,0)，返回的结果 123456789 function fun(n,o)&#123; //n的值为1，o的值为0 console.log(o); return &#123; fun:function(m)&#123; return fun(m,n);//n的值为1 &#125; &#125;;&#125;fun(1,0); //输出0，并返回一个对象，这个对象有一个fun的方法,这个方法调用后，会返回外层fun函数调用的结果，并且外层函数的第二个参数是 n 的值，也就是1 a.fun(2); 会怎么样？看代码 12345&#123; fun:function(2)&#123; return fun(2,0); &#125;&#125; a.fun(2); 返回的结果，就是 fun(2,0)，返回的结果 123456789function fun(n,o)&#123; //n的值为2，o的值为0 console.log(o); return &#123; fun:function(m)&#123; return fun(m,n); //n的值为2 &#125; &#125;;&#125;fun(2,0); //输出0，并返回一个对象，这个对象有一个fun的方法,这个方法调用后，会返回外层fun函数调用的结果，并且外层函数的第二个参数是 n 的值，也就是2 a.fun(3); 就不说了，一样的。 12var a = fun(0); a.fun(1); a.fun(2); a.fun(3);var b = fun(0).fun(1).fun(2).fun(3); 把返回的对象，重新赋值给a，这样两行的结果就是一样的了。var c = fun(0).fun(1); c.fun(2); c.fun(3);c 与他们的不同，只是var c = fun(0).fun(1); 之后用的是同一个对象罢了。 #总结说下结果 12345678var a = fun(0); a.fun(1); a.fun(2); a.fun(3);//undefined 0 0 0 var b = fun(0).fun(1).fun(2).fun(3);//undefined 0 1 2 var c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined 0 1 1 转载来自http://www.cnblogs.com/xxcanghai/p/4991870.html顺便推荐几篇讲解闭包的文章学习Javascript闭包（Closure）Javascript闭包——懂不懂由你，反正我是懂了 JS闭包可被利用的常见场景]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript推箱子]]></title>
    <url>%2F2018%2F11%2F24%2FSokoban%2F</url>
    <content type="text"><![CDATA[#前言 闲来没事做，想来没写过推箱子，便写来玩玩推箱子游戏的 逻辑非常简单，但是如果不动手的话，还是不太清楚。我在这里讲一下自己的思路。 思路 开始 html部分 样式 javascript部分 结语 #思路先来看下游戏资源 和地图的对比 123456789101112131415160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0,0, 0, 0, 0, 1, 1, 1, 3, 0, 3, 2, 1, 0, 0, 0, 0,0, 0, 0, 0, 1, 2, 0, 3, 4, 1, 1, 1, 0, 0, 0, 0,0, 0, 0, 0, 1, 1, 1, 1, 3, 1, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; 可以看到地图中的人物以及建筑是和数据中一一对应1对应树2对应球3对应箱子4对应人 那我们就可以根据数字去生成地图生成地图的同时给所有的dom赋值坐标轴 根据坐标轴来制定游戏规则 #开始#html部分123&lt;div id="box"&gt;&lt;/div&gt;&lt;script src="./js/mapdata100.js"&gt;&lt;/script&gt;&lt;!--mapdata100.js中的数组变量是levels--&gt; #样式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#box &#123; display: -webkit-flex; display: -moz-flex; display: -ms-flex; display: -o-flex; display: flex; flex-direction: column; width: 560px;&#125;#wrap &#123; position: relative; &#125;.item &#123; width: 35px; height: 35px; position: absolute;&#125;.item img&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); margin-top: -7px;&#125;#wrap .person &#123; z-index: 2;&#125;#wrap .person img&#123; margin-top: -17px;&#125;#button &#123; display: -webkit-flex; display: -moz-flex; display: -ms-flex; display: -o-flex; display: flex; flex-wrap: wrap; justify-content: center;&#125;#button p &#123; width: 100%; margin: 10px 0; text-align: center; &#125;#button button&#123; margin: 0 20px;&#125;#button div &#123; width: 100%; margin: 20px auto; text-align: center; &#125;#button input &#123; width: 40%;&#125; #javascript部分 定义一个函数123456window.onload =function()&#123; const box = document.getElementById('box'); var mygame = new game(); mygame.start(box);&#125;var game = function()&#123;&#125; 添加属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334game.prototype = &#123; variable: &#123; x: 16,//坐标 y: 16,//坐标 data:levels,//关卡数据 person: null,//人物 wrap: null,//地图盒子 buttonDiv: null,//按钮盒子 box: null,//传进来的盒子 /也就是父盒子 level: 0,//第几关 passNum: 0,//通关次数 stepNum: 0//步数统计 &#125;, //历史移动储存 用来返回上一步 step:&#123; person: [], box: [] &#125;, //开始 start:function (box)&#123; var wrap = document.createElement("div"); var button = document.createElement("div"); this.variable.wrap = wrap; this.variable.wrap.id = 'wrap'; this.variable.box = box; this.variable.buttonDiv = button; this.variable.buttonDiv.id = 'button'; this.variable.box.appendChild(this.variable.wrap); this.variable.box.appendChild(this.variable.buttonDiv); this.init(); &#125;, //地图初始化 init: function ()&#123; this.variable.wrap.innerHTML = '';//清空地图 this.variable.wrap.style.cssText = 'background:url(img/block.gif);' + 'width:'+ this.variable.x * 35 +'px;' + 'height:'+ this.variable.y * 35 +'px;';//布置地图 for(let k in this.variable.data[this.variable.level])&#123;//根据关卡循环游戏资源布置建筑 switch(this.variable.data[this.variable.level][k])&#123; //树 case 1: this.createBasic('wall',k); break; //球 case 2: this.createBasic('ball',k); break; //箱子 case 3: this.createBasic('box',k); break; //人物 case 4: this.createBasic('down',k); break; &#125; &#125; this.controlPerson(this.variable.person);//人物移动控制 this.createButton();//创建按钮 &#125;, //创建建筑 createBasic: function (type,k)&#123; var Odiv = document.createElement("div"); var Oimg = new Image(); var y = parseInt(k/this.variable.x);//商/即是y轴 var x = parseInt(k%this.variable.y);//余数即是x轴 if(type == "down")&#123; Odiv.className = 'item '+ "person";//人物给类 this.variable.person = Odiv;//人物存储 &#125;else &#123; Odiv.className = 'item '+ type;//type给类 &#125; Oimg.src = 'img/' + type + '.png';//src Odiv.x = x;//自定义属性，即元素存储坐标轴 也是用来判断人物/箱子/树/球之间的关系 也是思路的核心 Odiv.y = y; Odiv.style.cssText = 'left: '+ x*35+ 'px;top:' + y * 35 + 'px;z-index:' + (y*this.variable.x) +';';//坐标轴定义位置，z-index是为了上下层级(优化细节)/y越大的层级越高 Odiv.appendChild(Oimg); this.variable.wrap.appendChild(Odiv); &#125;, //创建按钮 createButton:function ()&#123; this.variable.buttonDiv.innerHTML = '';//清空按钮组 var _this = this;//点击事件要用的this变量 这里不懂得百度一下函数作用域和this指向 var p = document.createElement("p"); var next = document.createElement("button"); var prev = document.createElement("button"); var again = document.createElement("button"); var Prev_step = document.createElement("button"); var input_div = document.createElement("div"); var jump = document.createElement("button"); var text = document.createElement("input"); text.placeholder = 'Please enter 1~100 '; text.type = 'number'; input_div.appendChild(text); input_div.appendChild(jump); p.innerHTML = (this.variable.level+1) + 'level'; prev.innerHTML = 'prev level'; next.innerHTML = 'next level'; again.innerHTML = 'again'; Prev_step.innerHTML = 'Prev step'; jump.innerHTML = 'Level skip'; this.variable.buttonDiv.appendChild(p); this.variable.buttonDiv.appendChild(input_div); this.variable.buttonDiv.appendChild(prev); this.variable.buttonDiv.appendChild(next); this.variable.buttonDiv.appendChild(again); this.variable.buttonDiv.appendChild(Prev_step); prev.onclick = function ()&#123; _this.variable.level --;//关卡-1 if(_this.variable.level &lt; 0)&#123; _this.variable.level = 0; &#125; _this.init();//重新布置地图 &#125; next.onclick = function ()&#123; _this.variable.level ++;//关卡+1 if(_this.variable.level &gt; 99)&#123; _this.variable.level = 99; &#125; _this.init();//重新布置地图 &#125; again.onclick = function ()&#123; _this.init();//重新布置地图 &#125; Prev_step.onclick = function ()&#123; _this.prev(_this);//退回上一步 传入_this &#125; text.onkeyup = function ()&#123;//关卡跳转验证 var reg = new RegExp("^([1-9]|[1-9]\\d|100)$"); if(!reg.test(this.value))&#123; alert("请输入1-100的整数！") this.value = '' &#125; &#125; jump.onclick = function ()&#123;//关卡跳转 if(!text.value == '' || !text.value == null)&#123; _this.variable.level = text.value _this.variable.level = parseInt(_this.variable.level) _this.variable.level--//不知道为什么关卡+1了，这里需要-1 //我也想不明白 _this.init()//重新布置地图 &#125; &#125; &#125;, //人物控制 controlPerson: function (p)&#123; var img = p.firstElementChild;//div下的图片 var _this = this; //键盘事件要用的this变量 document.onkeydown = function (ev)&#123; ev = ev || window.event; var keycode = ev.keyCode; _this.step.person[_this.variable.stepNum] = &#123;&#125;//定义人物历史移动数据对象 _this.step.person[_this.variable.stepNum].src = _this.variable.person.firstElementChild.src;//人物历史移动朝向 switch(keycode)&#123; //left case 37: img.src = 'img/left.png'; _this.movePerson(&#123;x:-1&#125;,p);//传入x-1，即坐标轴x-1，向左移动一步 下面同理 break; //up case 38: img.src = 'img/up.png'; _this.movePerson(&#123;y:-1&#125;,p);//传入y-1，即坐标轴y-1，向上移动一步 下面同理 break; //right case 39: img.src = 'img/right.png'; _this.movePerson(&#123;x:1&#125;,p); break; //down case 40: img.src = 'img/down.png'; _this.movePerson(&#123;y:1&#125;,p); break; &#125; &#125; &#125;, //人物移动 movePerson: function (obj,el)&#123; var x = obj.x || 0; var y = obj.y || 0; var k = this.variable.data[this.variable.level][ (el.x+x) + (el.y+y) * this.variable.x ]; //当前数据 //(el.x+x) + (el.y+y) * this.variable.x为下标 var box = this.variable.wrap.querySelectorAll(".box"); if(k != 1)&#123;//如果人物没撞上树 移动 //存储上一步 this.step.person[this.variable.stepNum].x = el.x; this.step.person[this.variable.stepNum].y = el.y; //人物移动 el.x += x; el.y += y; el.style.left = el.x * 35 + 'px'; el.style.top = el.y * 35 + 'px'; el.style.zIndex = el.x + el.y * this.variable.x; //移动结束 this.variable.stepNum ++;//移动步数+1 for (var i = box.length - 1; i &gt;= 0; i--) &#123; if(box[i].x == el.x &amp;&amp; box[i].y == el.y)&#123;//人物移动后 人物与箱子的x，y相等 即人物撞上箱子 if(this.variable.data[this.variable.level][ (box[i].x+x) + (box[i].y+y) * this.variable.x ] != 1)&#123;//如果箱子没撞上树 //上面的(box[i].x+x) + (box[i].y+y) * this.variable.x 就是箱子在数据中的下标 if(this.collision(box[i],x,y))&#123;//判断箱子之间的碰撞 没用碰撞执行 this.step.box[this.variable.stepNum-1] = &#123;&#125;;//定义箱子的第·移动步数·个的对象 前面+1了，这里要-1 才是原来的步数 this.step.box[this.variable.stepNum-1].index = i;//箱子有未知个 要存储未知个箱子的上一步，就有未知个对象 存入this.step.box 也就是i个箱子 this.step.box[this.variable.stepNum-1].x = box[i].x;//上一步存入 this.step.box[this.variable.stepNum-1].y = box[i].y; //箱子移动 box[i].x += x; box[i].y += y; box[i].style.left = box[i].x * 35 + 'px'; box[i].style.top = box[i].y * 35 + 'px'; box[i].style.zIndex = box[i].x + box[i].y * this.variable.x; //移动结束 this.pass();//每一次箱子移动后 需要验证是否过关 &#125;else &#123;//箱子碰到箱子 箱子不做操作 但是上面人物已经移动 这里就需要把人还原 也就是坐标各-1 //人物移动 el.x -= x; el.y -= y; el.style.left = el.x * 35 + 'px'; el.style.top = el.y * 35 + 'px'; el.style.zIndex = el.x + el.y * this.variable.x; //移动结束 this.variable.stepNum --;//移动步数-1 this.step.person.pop();//上面人物移动前已经存储了历史移动 这里人物需要还原了 历史移动数组就得减去最后一个对象 &#125; &#125;else &#123;//如果箱子撞上树 箱子不做操作 但是上面人物已经移动 这里就需要把人还原 也就是坐标各-1 el.x -= x;//这里跟上面一样 还原 el.y -= y; el.style.left = el.x * 35 + 'px'; el.style.top = el.y * 35 + 'px'; el.style.zIndex = el.x + el.y * this.variable.x; this.variable.stepNum --; this.step.person.pop(); &#125; &#125; &#125; &#125; &#125;, //箱子与箱子的碰撞 collision: function (el,x,y)&#123; //传入得值分别是 box[i]第i个箱子,移动的x值,移动的y值(也就是this.movePerson中的x,y) var box = this.variable.wrap.querySelectorAll(".box");//所有的箱子 for (var i = box.length - 1; i &gt;= 0; i--) &#123; //循环所有箱子 if(box[i] != el)&#123;//两个箱子是不是同一个 if(box[i].x == el.x+x &amp;&amp; box[i].y == el.y+y)&#123;//下一步的坐标与一个箱子的坐标相等，也就是说两个箱子有重合， 返回false return false; &#125; &#125; &#125; //下一步的坐标与一个箱子的坐标不相等，也就是说两个箱子不重合， 返回true return true &#125;, //过关检测 pass: function ()&#123; var box = this.variable.wrap.querySelectorAll(".box");//箱子 var ball = this.variable.wrap.querySelectorAll(".ball");//球 var ballNum = 0;//箱子有未知个 要计数 for (var i = box.length - 1; i &gt;= 0; i--) &#123; for (var g = ball.length - 1; g &gt;= 0; g--) &#123; if(box[i].x == ball[g].x &amp;&amp; box[i].y == ball[g].y)&#123;//箱子和球的坐标相等 则成功的箱子+1 ballNum ++; &#125; &#125; &#125; if(ballNum == ball.length)&#123;//成功的箱子个数等于球的个数 游戏过关 alert("success"); this.variable.level ++;//成功后关卡+1 this.init();//重置地图 进入下一关 &#125; &#125;, //上一步 prev: function (_this)&#123; var w_box = _this.variable.wrap.querySelectorAll(".box");//所有箱子 if(_this.variable.stepNum != 0)&#123;//移动步数不等于0 _this.variable.person.x = _this.step.person[_this.variable.stepNum-1].x;//返回上一步 移动步数-1 赋值人物坐标 _this.variable.person.y = _this.step.person[_this.variable.stepNum-1].y; _this.variable.person.style.left = _this.variable.person.x * 35 + 'px';//人物坐标退回上一步 _this.variable.person.style.top = _this.variable.person.y * 35 + 'px'; _this.variable.person.style.zIndex = _this.variable.person.x + _this.variable.person.y * _this.variable.x;//层级也要重新赋值 _this.variable.person.firstElementChild.src = _this.step.person[_this.variable.stepNum-1].src;//人物朝向更改 if(_this.step.box[_this.variable.stepNum-1])&#123;//箱子与人物的移动步数不一样 另外判断 是否存在 var box_i = w_box[_this.step.box[_this.variable.stepNum-1].index]//第i个box 也就是箱子移动时储存的i box_i.x = _this.step.box[_this.variable.stepNum-1].x;//返回上一步 移动步数-1 赋值箱子坐标 box_i.y = _this.step.box[_this.variable.stepNum-1].y; box_i.style.left = box_i.x * 35 + 'px';//人物坐标退回上一步 box_i.style.top = box_i.y * 35 + 'px'; &#125; _this.variable.stepNum--;//返回上一步后 移动步数-1 &#125; &#125; &#125; #结语还是挺好玩的 啦啦啦啦预览]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>推箱子</tag>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[welcome]]></title>
    <url>%2F2018%2F11%2F20%2Ftest%2F</url>
    <content type="text"><![CDATA[123456 _ _ _____ _ ___ _____ _ _ _____( ) /\ ( ) ( ____) ( ) / _ \ ( _ ) ( ) ( ) ( ____) \ \ / \ / / | |___ | | | ( (_) | | | | | \ / | | |___ \ \/ \/ / | ___) | | | | _ | | | | | |\ \ / /| | | ___) \ /\ / | |___ | |____ | (_( ) | |_| | | | \ \/ / | | | |___ \_/ \_/ (_____) (______) \___/ (_____) (_) \__/ (_) (_____)]]></content>
      <tags>
        <tag>welcome</tag>
      </tags>
  </entry>
</search>
